\subsection{Introduction.}
Dans le cadre des TPE de première, nous avons voulu réaliser un lanceur de fléchette automatique. Il devait être capable de viser la cible quelle que soit sa position et de la lancer la fléchette sur une cible contenant des cercles concentriques. Il s'est vite avéré trop compliqué de faire exactement ça et nous avons donc du voir nos estimations à la baisse : au lieu de lancer des fléchette, nous lançons de petites billes magnétiques qui vont se coller sur la cible, qui doit donc être métallique. Ceci nous permet donc d'utiliser un canon Gauss (ou canon magnétique). La deuxième contrainte que nous avons rajouté est le placement du canon, qui doit se situer en face de la cible au niveau de son centre. De plus, afin de faciliter les calculs de balistique, nous avons décidé de ne faire bouger le canon que sur un seul axe, limitant les calculs à un espace en deux dimensions, tout en étant suffisant pour toucher chacun des cercles concentriques.

\subsection{Mon rôle.}
Le robot est contrôlé par une carte arduino Duemilanove, tandis que l'interface utilisateur se situe sur un smartphone android. Les deux communiquent par bluetooth. Mon rôle a été de développer l'application android qui dirige le robot. Il m'a donc fallu trouver un moyen de communiquer en bluetooth. J'ai donc chercher et comparé un certain nombre de shields bluetooth pour arduino avant de choisir un shield \emph{seeedstudio}, qui était très simple a utiliser car il fournissait des codes d'exemple ainsi qu'une interface \emph{Serial}. À la réception, nous avons des problèmes inattendus lors de la réception de données. Après de nombreux tests, je me suis rendu compte que ces valeurs avaient toutes un décalage de 128, ce qui correspond au bit de poids fort activé. Je suppose qu'il s'agit d'un système de test d'intégrité des données, ou alors tout simplement un bug. Toujours est il qu'une fois ce décalage pris en compte, nous n'avons plus eu de problème sur les transmissions de données.

Nous donc mis au point un protocole bluetooth, qui décrit précisément les échange entre la carte arduino et le smartphone, afin de permettre à ce dernier de bien contrôler le déroulement de la partie. Ce protocole est assez simple : afin de lancer une partie, le smartphone envoie à la carte arduino le niveau de difficulté choisit par l'utilisateur. Ensuite, le smartphone envoie à la carte l'ordre de charger le canon. À ce moment, la carte décide d'où elle va tirer, calcule l'angle et charge les condensateurs. Puis elle envoie au smartphone le signal qu'elle est prête. Le terminal android doit alors lui envoyer l'ordre de tirer pour que la carte tire. Cet enchainement continue jusqu'à ce que le smartphone envoie à la carte l'ordre de fin (il peu le faire à tout moment). La carte va alors attendre une nouvelle connexion (le protocole est détaillé en partie~\ref{ard_bt}).

La carte arduino choisit où elle va tirer en fonction du niveau de difficulté. Pour ce faire, elle découpe virtuellement la cible en trois bandes et leur donne à chacune une probabilité. Ces probabilités sont de $60\%$ sur la bande principale et de $40\%$ sur les autres bandes. Il existe quatre modes de difficulté : le mode facile (bande prédominante extérieure), le mode normal (bande prédominante au milieu), le mode difficile (bande prédominante intérieure) et le mode divin (toujours au centre). Plus de détail dans la partie~\ref{dif_lvl}.

Une fois le point d'impact choisit, la carte doit utiliser des formules de balistiques pour déterminer quel doit être l'angle du canon pour que le projectile atteigne le point voulu. J'ai donc du partir des formules de balistiques de terminal afin d'obtenir la formule de la trajectoire, puis, en la retravaillant, une formule qui associe l'angle de tir à la valeur algébrique entre le point d'impact est le centre de la cible. Cette formule a besoin d'un certain nombre d'autres paramètres pour être valable : $x$ la distance à la cible, mesurée en début de chaque partie, et $\overrightarrow{v}$ la vitesse initiale, une constante mesurée expérimentalement. Quelques autres paramètres interviennent aussi mais ils servent juste à adapter la formule à notre robot et ses spécificités (notamment le décalage entre le canon et le capteur de distance). Cette formule étant croissante, on peut procéder par dichotomie afin de déterminer l'angle nécessaire pour une hauteur sur la cible voulue. Les différentes formules sont détaillées partie~\ref{balis}.

\subsection{Conclusion.}
Ce projet a été très intéressant car il m'a permis d'améliorer sensiblement mes capacité en arduino dans le cadre d'un projet concret. J'ai du aborder de nombreux points intéressants, comme la communication bluetooth ou encore les calculs de balistique. De plus, c'est toujours gratifiant de voir le robot bouger et tirer sur une commande sans fil.

Ce projet a aussi été l'occasion de travailler en groupe. Ce n'est pas toujours facile de bien s'organiser mais nous avons réussi à bien découper les tâches et donc à éviter les redondances, malgré quelques conflits occasionnels. Ceci a été possible car nous avons tous dans le groupe des compétence différentes qui ont été valorisées par le projet.

